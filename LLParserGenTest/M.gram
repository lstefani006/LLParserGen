%lexer

fun                                   ^FUN

var                                   ^VAR
if                                    ^IF
else                                  ^ELSE
while                                 ^WHILE
break                                 ^BREAK
continue                              ^CONTINUE
return                                ^RETURN

true                                  ^TRUE
false                                 ^FALSE

","									  ^(,)
";"									  ^(;)
":"									  ^(:)
"+"									  ^(+)
"-"									  ^(-)
"*"									  ^(*)
"%"									  ^(%)
"|"									  ^(|)
"!"									  ^(!)
"^"									  ^(^)
"&"									  ^(&)
"/"									  ^(/)
"("									  ^(()
")"									  ^())
"{"									  ^({)
"}"									  ^(})
"["									  ^([)
"]"									  ^(])
"="									  ^(=)
">"									  ^GT
">="								  ^GE
"<"		    						  ^LT
"<="	    						  ^LE
"=="	    						  ^EQ
"!="	    						  ^NE
">>"	    						  ^SHR
"<<"	    						  ^SHL
"&&"	    						  ^ANDAND
"||"	    						  ^OROR

(_|[a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])* ^ID
[0-9]+                                ^NUM
(\ |\n|\r|\t)+                        ^()
\/\/.*                                ^()


%parser 
%parser.class MParser
%parser.using System
%parser.namespace LLParserGenTest

start<FunList>
	:                    ^new FunList()
	| start fun          ^$1.Add($2)
	;

fun<Fun>
	: FUN ID '(' funargse ')' ':' type '{' stmtlist '}'   ^new Fun($2, $4, $7, $9)
	;

funargse<FunArgList>
	:                      ^new FunArgList()
	| funargs              ^$1
	;

funargs<FunArgList>
	: ID ':' type                   ^new FunArgList($1, $3)
	| funargs ',' ID ':' type       ^$1.Add($3, $5)
	;

stmt<StmtRoot>
	: IF '(' e_ass ')' stmt             ^new StmtBlock(new StmtIf($1, $3, new StmtBlock($5)))
	| IF '(' e_ass ')' stmt *ELSE stmt  ^new StmtBlock(new StmtIf($1, $3, new StmtBlock($5), new StmtBlock($7)))
	| e_ass ';'                         ^new StmtExpr($2, $1)
	| VAR ID ':' type ';'               ^new StmtVar($1, $2, $4)
	| '{' stmtliste '}'                 ^new StmtBlock($1, $2)
	| WHILE '(' e_ass ')' stmt          ^new StmtBlock(new StmtWhile($1, $3, new StmtBlock($5)))
	| BREAK ';'                         ^new StmtBreak($1);
	| CONTINUE ';'                      ^new StmtContinue($1);
	| RETURN ';'                        ^new StmtReturn($1);
	| RETURN e_ass ';'                  ^new StmtReturn($1, $2);
	;


stmtliste<StmtList>
	: stmtlist              ^$1
	|                       ^new StmtList();
	;

stmtlist<StmtList>
	: stmtlist stmt          ^$1.Add($2)
	| stmt                   ^new StmtList($1)
	;

e_ass<ExprRoot>
	: e_oror '=' e_ass   ^new ExprAss($1, $3)
	| e_oror             ^$1
	;

e_oror<ExprRoot>
	: e_oror OROR e_andand    ^new ExprBinLogical("||", $1, $3)
	| e_andand                ^$1
	;

e_andand<ExprRoot>
	: e_andand ANDAND e_or    ^new ExprBinLogical("&&", $1, $3)
	| e_or                    ^$1
	;

e_or<ExprRoot>
	: e_or '|' e_xor    ^new ExprBinGen("|", $1, $3)
	| e_xor             ^$1
	;

e_xor<ExprRoot>
	: e_xor '^' e_and   ^new ExprBinGen("^", $1, $3)
	| e_and             ^$1
	;

e_and<ExprRoot>
	: e_and '&' e_eq   ^new ExprBinGen("&", $1, $3)
	| e_eq             ^$1
	;

e_eq<ExprRoot>
	: e_eq EQ e_lt    ^new ExprBinCompare("==", $1, $3)
	| e_eq NE e_lt    ^new ExprBinCompare("!=", $1, $3)
	| e_lt            ^$1
	;

e_lt<ExprRoot>
	: e_lt LT e_sh    ^new ExprBinCompare("<",  $1, $3)
	| e_lt LE e_sh    ^new ExprBinCompare("<=", $1, $3)
	| e_lt GT e_sh    ^new ExprBinCompare(">",  $1, $3)
	| e_lt GE e_sh    ^new ExprBinCompare(">=", $1, $3)
	| e_sh            ^$1
	;

e_sh<ExprRoot>
	: e_sh SHL e_add    ^new ExprBinGen("<<", $1, $3)
	| e_sh SHR e_add    ^new ExprBinGen(">>", $1, $3)
	| e_add             ^$1
	;


e_add<ExprRoot>
	: e_add '+' e_mul  ^new ExprBinGen("+", $1, $3)
	| e_add '-' e_mul  ^new ExprBinGen("-", $1, $3)
	| e_mul            ^$1
	;

e_mul<ExprRoot>
	: e_una            ^$1
	| e_mul '*' e_una  ^new ExprBinGen("*", $1, $3)
	| e_mul '/' e_una  ^new ExprBinGen("/", $1, $3)
	| e_mul '%' e_una  ^new ExprBinGen("%", $1, $3)
	;

e_una<ExprRoot>
	: e_prim           ^$1
	| '-' e_una        ^new ExprNeg($2)
	| '+' e_una        ^new ExprPlus($2)
	;

e_prim<ExprRoot>
	: NUM              ^new ExprNum($1)
	| ID               ^new ExprId($1)
	| FALSE            ^new ExprBool(false)
	| TRUE             ^new ExprBool(true)
	| '(' e_add ')'    ^$2
	| ID '(' e_list_opz ')'   ^new ExprFun($1, $3)
	;

e_list_opz<ExprList>
	:                   ^new ExprList()
	| e_list            ^$1
	;

e_list<ExprList>
	: e_ass               ^new ExprList($1)
	| e_list ',' e_ass    ^$1.Add($3)
	;


type<Type>
	: ID                  ^new SimpleType($1)
	| type '[' ']'        ^new ArrayType($1)
	;
