%lexer

fun                                   ^FUN

var                                   ^VAR
if                                    ^IF
else                                  ^ELSE
while                                 ^WHILE

","									  ^(,)
";"									  ^(;)
"+"									  ^(+)
"-"									  ^(-)
"*"									  ^(*)
"/"									  ^(/)
"("									  ^(()
")"									  ^())
"{"									  ^({)
"}"									  ^(})
"="									  ^(=)
">"									  ^GT
">="								  ^GE
"<"		    						  ^LT
"<="	    						  ^LE
"=="	    						  ^EQ
"!="	    						  ^NE

(_|[a-z]|[A-Z])(_|[a-z]|[A-Z]|[0-9])* ^ID
[0-9]+                                ^NUM
(\ |\n|\r|\t)+                        ^()


%parser 
%parser.class MParser
%parser.using System
%parser.namespace LLParserGenTest

start<Fun>
	: fun                ^$1
	;

fun<Fun>
	: FUN ID '(' funargse ')' '{' stmtlist '}'   ^new Fun($2, $4, $7)
	;

funargse<FunArgList>
	:                      ^new FunArgList()
	| funargs              ^$1
	;

funargs<FunArgList>
	: ID                   ^new FunArgList($1)
	| funargs ',' ID       ^$1.Add($3)
	;

stmt<StmtRoot>
	: IF '(' e_ass ')' stmt             ^new StmtIf($3, $5)
	| IF '(' e_ass ')' stmt *ELSE stmt  ^new StmtIf($3, $5, $7)
	| e_ass ';'                         ^new StmtExpr($1)
	| VAR ID ';'                        ^new StmtDecl($2)
	| '{' stmtliste '}'                 ^$2
	| WHILE '(' e_ass ')' stmt          ^new StmtWhile($3, $5)
	;

stmtliste<StmtList>
	: stmtlist              ^$1
	|                       ^new StmtList();
	;

stmtlist<StmtList>
	: stmtlist stmt          ^$1.Add($2)
	| stmt                   ^new StmtList($1)
	;

e_ass<ExprRoot>
	: e_lt '=' e_ass   ^new ExprAss($1, $3)
	| e_lt             ^$1
	;

e_lt<ExprRoot>
	: e_lt LT e_eq    ^new ExprEq("<",  $1, $3)
	| e_lt LE e_eq    ^new ExprEq("<=", $1, $3)
	| e_lt GT e_eq    ^new ExprEq(">",  $1, $3)
	| e_lt GE e_eq    ^new ExprEq(">=", $1, $3)
	| e_eq            ^$1
	;

e_eq<ExprRoot>
	: e_eq EQ e_add  ^new ExprEq("==", $1, $3)
	| e_eq NE e_add  ^new ExprEq("!=", $1, $3)
	| e_add            ^$1
	;


e_add<ExprRoot>
	: e_add '+' e_mul  ^new ExprAdd($1, $3)
	| e_add '-' e_mul  ^new ExprSub($1, $3)
	| e_mul            ^$1
	;

e_mul<ExprRoot>
	: e_una            ^$1
	| e_mul '*' e_una  ^new ExprMul($1, $3)
	| e_mul '/' e_una  ^new ExprDiv($1, $3)
	;

e_una<ExprRoot>
	: e_prim           ^$1
	| '-' e_una        ^new ExprNeg($2)
	| '+' e_una        ^new ExprPlus($2)
	;

e_prim<ExprRoot>
	: NUM              ^new ExprNum($1)
	| ID               ^new ExprId($1)
	| '(' e_add ')'    ^$2
	;
